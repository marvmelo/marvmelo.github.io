<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marcus' Personal Site</title>
    <link rel="stylesheet" href="../article.css">
</head>
<body>
    <h1>Space Shooter</h1>
    <h2>Introduction</h2>
    <p>In the first semester of 2020, which actually occurred in 2021 due to the pandemic, I took a course in <i>Introduction to Programming</i>. As our final assignment, we had to form groups and code a game. My group, actually a pair, was <a href="https://github.com/matheus-baraujo">Matheus de Ara√∫jo</a>. We decided early on to make something like <a href="https://en.wikipedia.org/wiki/Asteroids_(video_game)">Asteroid</a>. The project was named Unnamed-Asteroidlike-Game, it later changed to Space Shooter. The project was entirely made in Python, with Pygame, for it was the language we had learned.</p>
    <p>
        Later, I was challeged by a friend to remake the game in C, without any of Python's high-level features.
        I decided to take the challenge.
        It was very interesting learning experience.
        Altough the games look the same on surface, they work in very different ways. C's lack of OOP and Manual Memory Management broke a lot of engineering options that were pratical in Python.
        This time, I used Raylib as my library of choice.
    </p>
    <p>
        In this article I will not go in details about how everything works.
        I intent only to talk about some of the more interesting points of what I developed.
    </p>
    <h2>Space Shooter Classic</h2>
    <p><a href="https://github.com/marvmelo/space-shooter">Here</a> is the github repository of the game. The README is in Portuguese.</p>
    <p>Here is a video showcasing the game. It has music and sound effects, but my screen recording software could not capture it.</p>
    <p style="text-align: center;"><iframe src="https://www.youtube.com/embed/-fBdOWahAxM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
    <p>
        After some thought, my pair and I decided that we wanted a game where you could pilot a ship in 2D and shoot at enemy ships while they shoot back at you.
        You start the game with 5 lifes, which is the maximum you can have.
        Every time you get shot, you lose a life; every time you land a hit, you gain 50 points.
        We also have some power-ups.
        There is a life power-up, that restore a life up to 5, and a shield power-up, that protects you against one single bullet.
        We thought about adding a speed power-up, but that would be more annoying than helpful.
    </p>
    <p>After we split the task, I got to do mechanics of the game. I was mainly OOP code. There are 6 classes that make the game work. They are: <code>Spacecraft(), Player(Spacecraft), Enemy(Spacecraft), Projectile(), PowerUp(), Sprites()</code>.</p>
    <p>
        The <code>Spacecraft()</code> class contains data and methods that every ship will need, such as position on the screen, a rotation method, a translation method, etc.
        The <code>Player(...)</code> and <code>Enemy(...)</code> classes are children of <code>Spacecraft()</code>.
        They have more specific data and methods, such as a method that checks for user input, in the case of <code>Player(...)</code>, or a method that decides the correct time interval to shoot, in case of <code>Enemy(...)</code>.
    </p>
    <p>The most important class is Sprites, it is responsible for managing all other classes. Here is the data that is inside of it:</p>
    <pre>
        <code>
class Sprites():


    def __init__(self, player, score):

        self.enemy_projectiles = []
        self.powerups = []
        self.player_projectiles = []
        self.enemies = []
        self.player = player
        self.score = score
        </code>
    </pre>
    <p>
        As you can see, it contains some lists that contains objects of the other classes.
        The list has elements appended and removed as they appear and disappear on the screen.
        The <code>Sprites()</code> class has 2 methods that are called every frame: <code>update(...)</code> and <code>draw(...)</code>.
        They iterates over every list of objects and, respectively, call their methods that will update its data and draw it on the screen.
        This class is also responsible for running the RNG to decide when to include a new power-up or enemy on screen and checking for collisions. 
    </p>
    <p>
        How the object data is updated is different for every class, but it is mostly analytical geometry.
        The objects are drawn on the screen using some simple geometric shapes.
        Here is how it works for the <code>Projectile()</code> class:
    </p>
    <pre>
        <code>
def draw(self, screen):

    self.hitbox = pygame.draw.circle(screen, self.color, (self.x, self.y), self.radius)
        </code>
    </pre>
    <p>
        This is a very simple method, but it saves a lot of work.
        Besides drawing a circle on the screen the <code>pygame.draw.circle(...)</code> function returns a <code>Rect</code> object.
        This pygame class has built-in methods to check for collisions.
        This way, collision check is relatively simple.
    </p>
    <h2>Space Shooter C</h2>
    <p>
        <a href="https://github.com/marvmelo/space-shooter-c-rewriting">Here</a> the repository.
    </p>
    <p>
        Here is another video showcasing the game. It also has a background music that is absent.
    </p>
    <p style="text-align: center;"><iframe src="https://www.youtube.com/embed/6CN0ajd9lxE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
    <p>
        The first problem I had to overcome was the lack of OOP in C. 
        It turns out, OOP goes very well with game development.
        Altough it is possible to build objects in C, one has to consider that somethings are not meant to be.
        My solution was to create structs that were as general as possible and use a function to initialize them with the desirable data.
        Here is one example:
    </p>
    <pre>
        <code>
struct Spacecraft
{
    Vector2 vertices[3];
    Vector2 center;
    Color color;
    int life;
    int bulletLock;

    int hasShield;
    int score;

    int maxDistanceToPlayer;
    int direction;
};

int 
InitializeSpacecraft (struct Spacecraft *spacecraft, Vector2 center, int life, Color color)
{
    Vector2 vertex1 = {center.x, center.y - 15.0f};
    Vector2 vertex2 = {center.x - 15.0f, center.y + 15.0f};
    Vector2 vertex3 = {center.x + 15.0f, center.y + 15.0f};
    spacecraft->center = center;
    spacecraft->vertices[0] = vertex1;
    spacecraft->vertices[1] = vertex2;
    spacecraft->vertices[2] = vertex3;
    spacecraft->life = life;
    spacecraft->color = color;
    spacecraft->bulletLock = 0;
    spacecraft->hasShield = 0;
    spacecraft->score = 0;
    return 0;
};
        </code>
    </pre>
    <h6><a href="../../index.html">Go back</a></h6>
</body>
</html>
